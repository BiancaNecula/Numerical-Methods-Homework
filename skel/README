TEMA 1 METODE NUMERICE
Necula Bianca 315CA

Implementare task-uri:
->Task 1:
	->Generate probabilities system:
		- am observat forma si regulile aparitiei elementelor in matrice
		- matricea este patratica de dimensiunea rows(rows-1)/2 si diagonala principala reprezinta inversul probabilitatilor nodului indicelui respectiv
		- se itereaza prin diagonala si se seteaza valorile si pe fiecare rand respectiv nodului se steaza -1 in pozitiile vecinilor acestuia in functie de probabilitate
		- caz general al vecinilor pt un nod cu 6 iesiri: poz+row+1, poz+row, poz-row, poz-row+1, poz+1, poz-1
		- se creeaza vectorul b care contine cifra 1 pe ultimele rows pozitii
	->Matrix to csr:
		- se creeaza cei 3 vectori iterand prin matrice: values(valorile nenule), colind(indecsii valorilor nenule), rowptr(pointeri la primele elemente de pe fiecare rand)
	->Jacobi factorization: 
		- se foloseste algoritmul pentru factorizarea prin metoda Jacobi pe o matrice densa
		- se returneaza matricea de iteratie G si vectorul de iteratie c
	->Jacobi sparse:
		- se folosesc parametrii: matricea de iteratie in forma CSR si vector de iteratie si se aplica factorizarea Jacobi pentru a afla solutia sistemului.

->Task 2:
	->Clustering:
		- se initializeaza matricea de centroizi si o matrice binara de dimensiune nr_puncte x NC pt a tine minte clusterul initial
		- clusterul se initializeaza cu formula din cerinta: indice_punct % NC = i si se adauga 1 in matricea binara in locul punctelor centroizi
		- se calculeaza distanta euclidiana de la fiecare ounct l atoti centroizii, se salveaza intr-un vector si se alege minimul, reprezentand noul centroid apropiat de punct.
		- se face media punctelor fiecarui centrid si se alege noul centroid 
		- se pune 1 in matrice in dreptul centroizilor si se salveaza la fiecare iteratie
		- cand matricea este neschimbata de la o iteratie la alta se opreste algoritmul si returnam centroizii
	->Cost function:
		- se repeta prima parte a algoritmului de l aclustering si se calculeaza distantele euclidiene
		- se calculeaza suma minimului distantelor pt fiacare punct

->Task 3:
	->RGB Histogram:
		- se citeste imaginea din path-ul dat ca parametru, se extrag matricile reprezentative pt fiecare culoare din fiecare pixel
		- se calculeaza canalele pentru fiecare culoare dupa formula: culoare*count_bins/256
		- se foloseste functia accumarray pentru a reprezenta valorile culorilor in functie de aparitia acestora
		- se face asta pt cele 3 culori si se concateneaza output ul la final
	->HSV Histogram:
		- se transforma imaginea din RGB in HSV prin functia RGB2HSV scrisa vectorizat dupa algoritmul din cerinta
		- se urmaresc pasii de la RGB Histogram, doar ca in formula in loc de /256 apare /1.01 pt a separa datele potrivit si pentru ca matricele de culori se vor afla in rangeul [0,1]
	->Preprocess: 
		- se selecteaza imaginile din foldere /cats si /not-cats
		- in vectorul y se pune 1 pentru pozitiile imaginilor cats si -1 not_cats
		- in matricea X se vor pune pe fiecare linie hsitogramele calculate pt fiecare imagine in parte in functie de parametrul dat 'RGB' sau 'HSV'
	->SST:
		- se implementeaza algoritmul de rezolvare a unuisistem superior triunghiular
	->Householder:
		- se implementeaza algoritmul de descompunere QR Householder pt o matrice A
	->Learn:
		- se realizeaza matricea X_tilda ca fiind matricea X cu o coloana bias
		- se calculeaza Q, R cu Householder si se afla solutia w cu ajutorul SST
	->Evaluate:
		- se stabilesc X si y pt imaginile de testare
		- se calculeaza y prin inmultirea matricei X cu vectorul invatat w
		- se compara valorile din cei doi vectori y si se afla cate valori din total sunt identice
		- se returneaza acest numar ca procentaj

->Task 4:
	->Functii implementate la Task 3
	->Learn: 
		- se scaleaza X si se construieste X_tilda
		- se foloseste algoritmul dat in cerinta pentru a afla w
	->Evaluate:
		- este acelasi mod de rezolvare ca la taskul 3
 

